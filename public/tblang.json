{
  "id": "tblang",
  "title": "TBLang",
  "link": "http://localhost:3000/assets/tblanglogo.png",
  "header": "A look into TBLang",
  "text": "I am creating a programming language, which I have chosen to name TBLang. This blog exists to document my process, and the journey of which I am taking in creating it. Hopefully this reading will be insightful to those reading it. When deciding to create a programming language, the last thing I really wanted to do was to start coding. I have tried to create one before, and fell flat on my face because I knew of the lexer, compiler, and debug process and figured that if I created those I would be good to go. As it turns out, creating a programming language requires far more than just a basic understanding of these concepts. I know this time I will need to understand thoroughly the process in which a programming language works, step by step, and hopefully in the process reinvent the wheel rather than trying to copy something I don't entirely understand. So, what is my plan then? I believe a good start is to look at esoteric languages like 'Brainfuck' and its derivatives, one particular favorite of mine being 'MooLang', as an example of how this is done. These languages are open source, and show you exactly how the process works in a way which is far easier to understand than a language like C# or python. And so with some of these examples in mind, my plan is to create a statically typed language which aims to be readable for programmers. I will implement it using C++. Now, with that out of the way, what's the first step in getting this project going? There are infinite ways of going about this, although some are certainly better than others. I will lay out my strategy here. Step 1: Break down the problem into its smallest possible components. Here are the individual components I personally found: 'Error checking the text''Converting programmer text into a syntax tree''Converting syntax tree into assembly''Converting assembly into binary''Define syntax''Is the language turing complete?' Notice how each one of these is a smaller project which can be completed in isolation of the overarching project. The goal for breaking down larger problems, from my perspective, is to be able to complete a series of small problems and then have a nearly finished overarching project at the end of it. At that point one would ideally be able to combine the smaller projects into one larger one, which would then be mostly if not completely functional.",
  "sample": "Lorem Ipsum"
}
